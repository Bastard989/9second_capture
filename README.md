# 9second_capture

Статус: в разработке.

Локальный агент для записи встреч с компьютера пользователя: захват системного звука, транскрибация, аналитика и экспорт результатов. Работает на локальной машине и сохраняет все данные на диск пользователя.

## Идея продукта

Пользователь устанавливает агент на свой ПК, запускает его одним кликом и получает локальный веб-интерфейс. Через него можно начать/остановить запись, проверить входной звук и скачать результаты. Никакие данные не уходят в облако без явного решения пользователя.

## Как это работает

1) Агент запускается и поднимает локальную страницу (127.0.0.1). Порт выбирается автоматически (свободный).
2) Пользователь проверяет доступность/наличие драйвера захвата звука.
3) После нажатия Start идёт отсчёт 9 секунд, затем начинается запись.
4) Агент захватывает системный звук (или fallback — захват экрана со звуком) и обрабатывает запись.
5) Во время записи LLM (по настройке) очищает текст и помогает определить, кто говорит.
6) По завершении формируются raw/clean транскрипты (raw от STT, clean после очистки/LLM).
7) По кнопке LLM формирует отчет (отдельно для raw/clean).
8) По кнопке LLM формирует структурированные табличные данные (CSV/JSON) отдельно для raw/clean.
9) Все результаты доступны для просмотра и скачивания по кнопке (без авто‑скачивания).
10) Дополнительно: можно загрузить конференцию как файл (аудио/видео) и прогнать через тот же пайплайн.

## Что сохраняется локально

- raw transcript (сырой текст, STT)
- clean transcript (очищенный текст, LLM по настройке)
- отчет (summary/analytics) — по кнопке LLM
- structured data (CSV/JSON) — по кнопке LLM, отдельно для raw и clean
- результаты хранятся локально в хранилище агента и доступны для просмотра/скачивания (без авто‑скачивания)

Схема структурированных данных: `docs/structured_schema.md`.

## Драйверы захвата звука

Системный звук требует виртуального аудио-драйвера. Мы оставляем установку драйвера на пользователе, а агент дает инструкцию и проверяет наличие сигнала. Если системный звук недоступен, возможен fallback через захват экрана со звуком.

### Инструкция по установке (по ОС)

macOS:
- Установить виртуальный драйвер захвата системного звука (например, BlackHole).
- В Audio MIDI Setup создать Multi‑Output Device (включить колонки + BlackHole).
- В UI агента выбрать BlackHole как источник входа.

Windows:
- Установить виртуальный кабель (например, VB‑CABLE).
- Переключить вывод системы на “CABLE Input”.
- В UI агента выбрать “CABLE Output” как источник входа.

Linux (PulseAudio / PipeWire):
- Убедиться, что доступен “Monitor of <device>” (loopback/monitor sink).
- В UI агента выбрать “Monitor of …” как источник входа.

Если драйвер недоступен, используем fallback через захват экрана со звуком.

## UI-логика (локальный веб-интерфейс)

Основные действия:
- Проверить наличие/доступность драйвера захвата звука
- Начать запись / Остановить запись (запись запускается через 9 секунд после нажатия Start)
- Загрузить конференцию как файл (аудио‑анализ работает)
- Загрузить конференцию как файл (видео‑анализ в разработке, нужен мультимодальный LLM)
- Просмотр и скачивание raw/clean транскриптов, отчёта и structured‑данных (по кнопке)
- Сформировать отчёт (raw/clean) по кнопке LLM
- Сформировать structured‑данные (raw/clean) по кнопке LLM
- Переключение языка RU/EN

## Дорожная карта (без сроков)

Принятые решения:
- Локальный агент + локальный web-интерфейс вместо полноразмерного GUI.
- Автовыбор свободного порта при старте (fallback по диапазону + запоминание удачного порта).
- Двухъязычный UI (RU/EN) с переключателем.
- Запись запускается только по кнопке (после 9-секундного отсчёта) и останавливается по кнопке.
- Драйверы захвата звука устанавливает пользователь; агент проверяет наличие/доступность драйвера.
- Результаты хранятся локально; скачивание — по кнопке (без авто‑скачивания).
- Structured данные формируются по кнопке после завершения встречи (raw/clean отдельно, экспорт CSV/JSON).
- Идентификация говорящих: ведущий представляется в начале; обращения по имени используются для сопоставления speaker‑кластеров.
- LLM работает в двух слоях:
- во время записи (очистка текста и определение говорящих)
- по кнопке (отчёт и табличные данные)
- Окно ответа после обращения по имени: 6–10 секунд (конфигурируемо).
- Если адресат не отвечает и явно упоминается отсутствие/ответ за него, ответ помечается как “proxy for <имя>”.

План развития:
1) Локальный режим записи + базовый UI (Старт/Стоп, статус, проверка звука, 9‑секундный отсчёт).
2) Локальные результаты и список записей (скачивание файлов).
3) Structured данные по кнопке (LLM) + экспорт CSV/JSON.
4) Лаунчер для macOS/Windows/Linux (иконка, автозапуск UI).
5) Полировка UX/инструкций/валидаций.
6) Опционально: режим синхронизации результатов с сервером (по желанию пользователя).

## Dev quickstart (для разработчиков)

- `docker compose up -d --build`
- Проверка API: `http://localhost:8010/health`
- Метрики: `http://localhost:8010/metrics`

## Локальный UI (агент)

Для локального web-интерфейса со стартом/стопом записи и проверкой сигнала:

- `AUTH_MODE=none STT_PROVIDER=mock LLM_ENABLED=false LLM_LIVE_ENABLED=false python3 scripts/run_local_agent.py`
- Скрипт сам выберет свободный порт в диапазоне `8010–8099` и запомнит его в `./data/local_agent/state.json`.
- UI откроется по адресу вида `http://127.0.0.1:<порт>`.

Важно:
- Запущенный UI использует тот же backend, поэтому Redis/Postgres/воркеры должны быть доступны
  (проще всего поднять через `docker compose up -d --build`).

Минимальный `.env` для старта:
- `APP_ENV=dev`
- `AUTH_MODE=api_key`
- `API_KEYS=dev-user-key`
- `SERVICE_API_KEYS=dev-service-key`
- `RECORDS_DIR=./data/records` (по умолчанию)

## Packaging (launcher)

Базовые инструкции по сборке бинарников: `tools/packaging/README.md`.
